#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Autopoweroff, version @version@

import logging
import logging.config
import os
import re
import signal
import sys
import time
import traceback

gTestMode = "@production@" != "true"

# Fork to disconnect from the terminal, if in production.
if not gTestMode and os.fork() != 0:
  sys.exit(0)

scriptname = os.path.basename(sys.argv[0])

if not gTestMode:
  startMsgExtra = ""
  programname = "@program_name@"
  sharedir    = "@autopoweroff_sharedir@"
  modulesdir  = sharedir + '/autopoweroff/python/modules'
  confdir     = "@autopoweroff_confdir@"
  rundir      = "@autopoweroff_rundir@"
  piddir      = "@autopoweroff_piddir@"
  pidfile     = "@autopoweroff_pidfile@"
  loggingFile = "autopoweroff-logging.conf"
else:
  # We are in test mode.  Using relative values.
  startMsgExtra = " - Test mode enabled"
  scriptPath=os.path.dirname(sys.argv[0])
  basePathAbs=os.path.realpath(scriptPath + "/..")
  programname = "Autopoweroff"
  sharedir    = basePathAbs
  modulesdir  = basePathAbs + '/python/modules'
  confdir     = basePathAbs + "/etc/" + programname.lower()
  rundir      = "/tmp/" + programname.lower() + "-test/var"
  piddir      = rundir
  pidfile     = "autopoweroff-test.pid"
  loggingFile = "autopoweroff-logging-debug.conf"

logConfigFile = confdir + "/" + loggingFile
logConfigFile

logging.config.fileConfig(logConfigFile)
logger = logging.getLogger(programname)
pid = str(os.getpid())
logger.info("══════════════════════════════════════════════════════════")
sys.path.append(modulesdir)
from ApoLibrary import *

sendmsg(programname + " started with PID '" + pid + "'" + startMsgExtra + ".")
logger.info("Logging configuration file used:  " + logConfigFile)

if os.getuid() != 0:
  sendmsg("Must be executed as root.")
  sendmsg

  sys.exit(1)

createDirs([piddir, rundir])
conffile = confdir + "/" + scriptname + ".conf"

if os.path.exists(pidfile):
  fdPidFile = open(pidfile)
  pid = fdPidFile.readline()
  fdPidFile.close()
  try:
    os.kill(int(pid), signal.SIGTERM)
    sendmsg("Currently running instance killed.", level=syslog.LOG_ALERT)
  except OSError as oserror:
    if oserror.errno != errno.ESRCH:  # No such process
      # errno ESRCH (#3) means that the process does not exist.
      # If such is the case, we ignore the exception, else, we raise it.
      raise

######################################################################
# Lock file creation to ensure only one instance of this script is running.
lockFile = open(pidfile, 'w')
lockFile.write(pid)
lockFile.close()

# ======================================================================
# SIGTERM Handler
def sigtermHandler(_signo, _stack_frame):
  sendmsg("Graceful shutdown initiated.  Please wait around 30s.")

  global apoObserverDeviceManager
  apoObserverDeviceManager.terminate()

  global apoObserverResources
  apoObserverResources.terminate()
  apoObserverResources.join()

  global aoha
  aoha.terminate()
  aoha.join()

  global apoObserverNoActionTimeRange
  apoObserverNoActionTimeRange.terminate()
  apoObserverNoActionTimeRange.join()

  global pidfile
  os.remove(pidfile)

  global pid
  sendmsg(f"Shutdown completed.  Process PID #{pid} is no more.")
  logging.shutdown()  # Graceful shutdown of loggers with flushing accomplished.
  sys.exit(0)


# ======================================================================
# The system must remain on for at least the 'startupdelay' first minutes
# it was started.
def startupDelay():
  if not gTestMode:
    sendmsg("Startup sleep of " + str(configuration.startupdelay) + " minutes.")
    time.sleep(configuration.startupdelay * 60)

signal.signal(signal.SIGTERM, sigtermHandler)

# ======================================================================
# Configuration
import ApoConfig
cancelfile = rundir + "/" + ApoConfig.CANCELFILENAME

configuration = ApoConfig.Configuration(None, None, None, None)
try:
  configuration.read()
except ApoConfig.APOWarning as message:
  sendmsg(message)
except ApoConfig.APOError as message:
  sendmsg(message)

command = ""
if configuration.action is None:
  # Default command is SLEEP.  It is safer as no actual data can be lost going
  # to sleep where a shutdown might cause data lost because saving operations
  # could not be performed.
  command = APOCommand.commands[APOCommand.SLEEP]
  commandtext = APOCommand.SLEEP
if configuration.action == APOCommand.OTHER:

  command = configuration.actioncommand
  commandtext = "executing '" + command + "'"
else:
  command = APOCommand.commands[configuration.action]
  commandtext = APOCommand.commands[configuration.action]

sendmsg("Command to execute when all conditions are met:  " + command)

######################################################################
# Starting thread that checks if any host is still alive.
# The global gHostsStillAlive variable is updated by this thread
# and used by the main one to get the list of all hosts still alive.
import ApoObserverHostsAlive

global gHostsStillAlive
gHostsStillAlive = []

aoha=ApoObserverHostsAlive.ApoObserverHostsAlive(configuration.hosts)
aoha.start()

import ApoObserverNoActionTimeRange
apoObserverNoActionTimeRange=ApoObserverNoActionTimeRange.ApoObserverNoActionTimeRange(configuration)
apoObserverNoActionTimeRange.start()


######################################################################
# Loading kernel power management module.
# For the moment, not required.
# import commands;commands.getstatusoutput("/sbin/modprobe apm")

import ApoObserverDevice
apoObserverDeviceManager = \
  ApoObserverDevice.ApoObserverDeviceManager(configuration)

import ApoObserverResources
apoObserverResources = ApoObserverResources.ApoObserverResources(configuration)

def conditionsArrayToString(conditions):
  keyprint = "[ "
  for key, value in conditions.items():
    keyprint=keyprint + key + ":" + str(value) + " "
  keyprint=keyprint + "]"
  return keyprint


def setConditions(status):
  isConditionMet = status[0]  # Boolean.
  name           = status[1]  # String.
  description    = status[2]  # String.

  conditionsState      [name] = isConditionMet
  conditionsDescription[name] = description


######################################################################
try:

  while True:  # Outer loop.

    isToBePutOnHold = False
    alivePrint      = False
    isThereAnyConditionsNotMet = False

    # Conditions descriptions are String that can change with time.
    # Thus they must not be part of conditionsState else the comparison
    # with previousConditionsState will always show that the state changed
    # even though only the description changed, not the actual state.
    conditionsDescription = {}
    conditionsState       = {}

    startupDelay()

    while True:  # Inner loop

      previousConditionsState = conditionsState.copy()

      setConditions(apoObserverNoActionTimeRange.status())
      setConditions(apoObserverDeviceManager.status())
      setConditions(apoObserverResources.status())

      logger.debug("conditionsState:  " + str(conditionsState))
      logger.debug("previousConditionsState:  " + str(previousConditionsState))

      if conditionsState != previousConditionsState:
        isThereAnyConditionsNotMet = False
        sendmsg("Conditions have changed.  New conditions:")
        for key, value in conditionsState.items():
          if(value == False):
            isThereAnyConditionsNotMet = True
          sendmsg("  " + conditionsDescription[key])
        logger.debug( \
          "Conditions array:  " + conditionsArrayToString(conditionsState))

      if isThereAnyConditionsNotMet:
        logger.debug("At least one condition is not met.  Looping." + \
                     str(conditionsState))
        # Arbitrary 5s sleep.  If this sleep is removed, Autopoweroff will
        # run at 100% CPU since it will endlessly loop until the condition
        # changes.
        try:
          time.sleep(5)
          continue
        except KeyboardInterrupt as ki:
          break

      # Taking a snapshot because if aoha.hostsStillAlive is used everywhere,
      # its value might change during it's utilization, as
      # aoha.hostsStillAlive is set in another thread.  By taking a snapshot,
      # the value will not change since the ApoObserverHostsAlive does not
      # play with the content of the list, but replace it completely with a
      # new one.
      hostsStillAlive = aoha.hostsStillAlive

      logger.debug("aoha.hostsStillAlive = " + str(hostsStillAlive))

      if len(hostsStillAlive) > 0:
        if not alivePrint:
          sendmsg("Some hosts are still alive:  " + str(hostsStillAlive))
        alivePrint = True

        # Arbitrary 5s sleep.  If this sleep is removed, Autopoweroff will run
        # at 100% CPU since it will endlessly loop until the condition
        # changes.
        time.sleep(5)
        continue
      else:
        while os.path.exists(cancelfile):
          if not isToBePutOnHold:
            isToBePutOnHold = True
            sendmsg(programname +
                    " disabled as requested (detected presence of '" +
                    cancelfile + "').")
          time.sleep(1 * 60)
          continue

        isToBePutOnHold = False

        sendmsg("All the conditions are met for running the action.",
                level=syslog.LOG_ALERT)

        if gTestMode:
          sendmsg( \
              "Test mode:  would have run action '" + command + "' at " + \
              time.strftime("%H:%M:%S", (time.localtime(time.time()))))

        else:
          import subprocess
          subprocess.getstatusoutput(command)

        # Arbitrary 5s sleep.  If this sleep is removed, Autopoweroff will run
        # at 100% CPU since it will endlessly loop until the condition
        # changes.
        time.sleep(5)

        # If the command is executed and we return, we get out of the inner
        # loop and fall into the outer loop, reinitializing some crucial
        # variables as if the program was restarted.
        break

     # Only poweroff if it has been determined that this is the action to do.
     # Remember, autopoweroff could have received a SIGTERM (CTRL-C).
     #
     # The while loop can end when finish == True or if autopoweroff
     # receives a SIGTERM signal.
    sigtermHandler(None, None)

except Exception as exception:
  logger.error(str(exception))
  logger.error(traceback.format_exc())
  sigtermHandler(None, None)
