#!/usr/bin/python

# Autopoweroff, version @version@

import sys
import commands
import os
import syslog
import time
import re
import signal
import threading

testmode = "@production@" != "true"

if testmode:
  # We are in test mode.  Using relative values.
  sharedir = ".."
  etcdir   = "../etc"
  vardir   = "/tmp/autopoweroff/var"
  ctrldir  = "/tmp/autopoweroff/var"
else:
  sharedir = "@autopoweroff_sharedir@"
  etcdir   = "@autopoweroff_etcdir@"
  vardir   = "@autopoweroff_vardir@"
  ctrldir  = "@autopoweroff_ctrldir@"

sys.path.append(sharedir + '/python/modules')

from apoconfig import *
import apoconfig

try:
  os.makedirs(vardir)
except OSError, oserror:
  # Error #17 is "File exists", which we ignore.  If anything
  # else, we raise it.
  if oserror[0] != 17:
    raise oserror

pidfile    = vardir  + "/" + scriptname + ".pid"
cancelfile = ctrldir + "/" + scriptname + ".cancel"
conffile   = etcdir  + "/" + scriptname + ".conf"

# The "No shutdown range" is the range, expressed in hours, during which no
# shutdown is to be performed.
# Expressed in local time, not UTC.

if os.path.exists(pidfile):
  fdPidFile=open(pidfile)
  pid=fdPidFile.readline()
  fdPidFile.close()
  try:
    os.kill(int(pid), signal.SIGTERM)
    sendmsg("Currently running instance killed.", syslog.LOG_ALERT)
  except OSError, (errno, msg):
    if errno != 3:  # errno #3 means that the process does not exist.
                    # if such is the case, we ignore the exception.
      raise

configuration = apoconfig.Configuration(None, None, None, None)
try:
  configuration.read()
except apoconfig.APOWarning, message:
  sendmsg(message)
except apoconfig.APOError, message:
  sendmsg(message)

#debug("idletime=" + str(configuration.idletime))

if not testmode and os.fork() != 0:
  sys.exit(0)

sendmsg("Successfully started as PID: " + str(os.getpid()))


######################################################################
# Lock file creation to ensure only one instance of this script is running.
file=open(pidfile, 'w')
file.write(str(os.getpid()))
file.close()


######################################################################
# The system must remain on for at least the 'startupdelay' first minutes
# it was started.
if not testmode:
  sendmsg("Startup sleep of " + str(configuration.startupdelay) + " minutes.")
  time.sleep(configuration.startupdelay*60)


######################################################################
# Loading kernel power management module.
# For the moment, not required.
#commands.getstatusoutput("/sbin/modprobe apm")

gLastInputEventTime = time.time()

class ApoDeviceObserverThread(threading.Thread):

  def __init__(self, sDevice):
    threading.Thread.__init__(self, name=sDevice)
    self.setDaemon(True)
    self.sDevice = sDevice
    self.sleep = 0

  def run(self):
    global gLastInputEventTime
    fd=open(self.sDevice, 'r')
    debug("ApoDeviceObserverThread.run():  Check on " + \
        self.sDevice + " started.")
    self.finish = False
    lastEventTime = 0.0
    while not self.finish:
      if self.sleep > 0:
        time.sleep(self.sleep)
        self.sleep = 0

      fd.read(1)
      currentTime=time.time()
      gLastInputEventTime=currentTime
      #print currentTime-lastEventTime
      # To reduce the quantity of output, we print only a few
      # of the events, for debugging purposes.  Else, it is simply
      # to much.
      if currentTime > lastEventTime + 0.01:
        debug("ApoDeviceObserverThread.run():  Activity detected on " + \
            self.sDevice + " at " + str(currentTime))
      lastEventTime = currentTime
    fd.close()

  def terminate(self):
    self.finish = True

  def sleep(self, timeout):
    self.sleep = timeout

aDevices   = []
aApoDevObs = []

try:
  spkrRE = re.compile(".*spkr.*")
  #devicePath="/dev/input"
  devicePath="/dev/input/by-path"
  for path in os.listdir(devicePath):
    if spkrRE.search(path) != None:
      # Ignoring speaker devices.  I do not understand how
      # a device related to a speaker can be considered an input
      # device.  This is the case in Ubuntu 07.04.
      continue

    path = devicePath + "/" + path
    debug("path = " + path)
    aDevices.append(path)

except OSError, oserror:
  if oserror.errno != errno.ENOENT:
    raise oserror

for sDevice in aDevices:
  debug("sDevice = " + sDevice)
  apoDevObs=ApoDeviceObserverThread(sDevice)
  apoDevObs.start()
  aApoDevObs.append(apoDevObs)



######################################################################
isToBeSuspended = False
finish = False
while not finish:

  # Checking if the current hour is within the poweroff shutdown range.
  # Now contains the current hour.

  now = time.time()
  #debug("UTC:  ", time.gmtime(now))
  #debug("LOCAL:  ", time.localtime(now))
  nowtuple = time.localtime(now)
  nowhour = nowtuple[3]
  #debug(nowhour)

  if nowhour >= configuration.noshutdownrange[0] and \
     nowhour < configuration.noshutdownrange[1]:
    shutdowntuple=(nowtuple[0], nowtuple[1], nowtuple[2],
                   configuration.noshutdownrange[1],
                   0, 0, nowtuple[6], nowtuple[7], nowtuple[8])
    #debug(shutdowntuple)
    #debug(nowtuple)
    sleeptime=time.mktime(shutdowntuple)-now

    # Using gmtime(sleeptime) here because localtime(0) is actually
    # 1969/12/31 19h00, thus if using localtime(sleeptime), we actually
    # print the sleeptime minus 5 hours, which is wrong.
    sendmsg("Currently not in time range " + \
            str(configuration.noshutdownrange) + \
            " for system shutdown.\nSleeping for " + \
            time.strftime("%H:%M:%S", time.gmtime(sleeptime)),".")
    time.sleep(sleeptime)
    continue

  if os.path.exists(cancelfile):
    if not isToBeSuspended:
      isToBeSuspended = True
      sendmsg("Suspended as requested.")
    time.sleep(15)
    continue
  else:
    isToBeSuspended = False
 
  # HANS:  TODO:
  # to check if gm
  nowTime = time.time()
  timeElapsedSinceLastEvent = nowTime - gLastInputEventTime

  debug("timeElapsedSinceLastEvent = " + str(timeElapsedSinceLastEvent))

  # If configuration.idletime is set to 0, that means that the user
  # does not want any of the console inputs to influence the
  if configuration.idletime > 0 and \
     timeElapsedSinceLastEvent < configuration.idletime*60:
    debug("User is active.")
    sleeptime=None
    if testmode:
      sleeptime=2
    else:
      sleeptime=configuration.idletime*60
    debug("Sleeping for " + str(sleeptime) + "s.")
    time.sleep(sleeptime)
    continue

  isOneStillAlive=False

  # Eventually, the following code for pinging hosts should be threaded
  # so this could be done in the background.
  for host in configuration.hosts:
    #debug("Pinging host:  >>" + host + "<<")
    status = commands.getstatusoutput("ping -c 1 -w 10 " + host)[0]
    #debug(status)
    #signal = status & 0xFF
    exitcode = (status >> 8) & 0xFF
    #debug(exitcode)
    if exitcode == 0:
      isOneStillAlive=True
      break

  if isOneStillAlive:
    sendmsg("At least one host is still alive.")
    time.sleep(5)
    continue
  else:
    sendmsg("All the conditions for shutdown are met.  System shutdown.", \
            syslog.LOG_ALERT)
    finish = True
  # Checking if anybody is working on the server.  No shutdown if there
  # is activity on the keyboard or on the mouse.

for thread in aApoDevObs:
  thread.terminate()

os.remove(pidfile)
sendmsg("Ending.")

# Only poweroff if it has been determined that this is the action to do.
# Remember, autopoweroff could have received a SIGTERM (CTRL-C).
#
# The while loop can end when finish == True or if autopoweroff
# receives a SIGTERM signal.
if finish:  # No SIGTERM signal received and clean shutdown required.
  if testmode:
    print "Powering off at " + time.strftime("%H:%M:%S", \
      (time.localtime(time.time())))
  else:
    #commands.getstatusoutput("nohup poweroff");
    #commands.getstatusoutput("nohup /sbin/shutdown -h now");
    print "ERROR:  POWEROFF COMMAND DISABLED FOR DEBUGGING PURPOSES."
