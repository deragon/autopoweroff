#!/usr/bin/python

# Autopoweroff, version @version@

import sys
import commands
import os
import syslog
import time
import re
import signal
import threading
import errno
import logging
import logging.config

testmode = "@production@" != "true"

# Fork to disconnect from the terminal, if in production.
if not testmode and os.fork() != 0:
  sys.exit(0)

scriptname = os.path.basename(sys.argv[0])

if testmode:
  # We are in test mode.  Using relative values.
  programname = "autopoweroff"
  sharedir = ".."
  etcdir   = "../etc/" + programname
  rundir   = "/tmp/" + programname + "-test/var"
  piddir   = rundir
  pidfile  = "autopoweroff-test.pid"
  loggingFile="autopoweroff-logging-debug.conf"
else:
  logging.basicConfig(level=logging.INFO)
  programname = "@program_name@".lower()
  sharedir = "@autopoweroff_sharedir@"
  etcdir   = "@autopoweroff_etcdir@/" + programname
  rundir   = "@autopoweroff_rundir@"
  piddir   = "@autopoweroff_piddir@"
  pidfile  = "@autopoweroff_pidfile@"

logging.config.fileConfig(sharedir + "/" + loggingFile)
logger = logging.getLogger(__name__);

sys.path.append(sharedir + '/python/modules')

import apoconfig
from apolib import *

if os.getuid() != 0:
  sendmsg("Must be executed as root.")
  sys.exit(1)

createDirs([ piddir, rundir ])
cancelfile = rundir + "/" + scriptname + ".cancel"
conffile   = etcdir + "/" + scriptname + ".conf"

# The "No shutdown range" is the range, expressed in hours, during which no
# shutdown is to be performed.
# Expressed in local time, not UTC.

if os.path.exists(pidfile):
  fdPidFile=open(pidfile)
  pid=fdPidFile.readline()
  fdPidFile.close()
  try:
    os.kill(int(pid), signal.SIGTERM)
    sendmsg("Currently running instance killed.", syslog.LOG_ALERT)
  except OSError, oserror:
    if oserror.errno != errno.ESRCH:  # No such process
      # errno ESRCH (#3) means that the process does not exist.
      # If such is the case, we ignore the exception, else, we raise it.
      raise


# ======================================================================
# SIGTERM Handler
def sigtermHandler(_signo, _stack_frame):
  print "sigtermHandler() called."
  global ApoDevObsArray
  for thread in ApoDevObsArray:
    thread.terminate()

  global pidfile
  os.remove(pidfile)
  sendmsg("Ending.")

signal.signal(signal.SIGTERM, sigtermHandler)


# ======================================================================
# Configuration
configuration = apoconfig.Configuration(None, None, None, None)
try:
  configuration.read()
except apoconfig.APOWarning, message:
  sendmsg(message)
except apoconfig.APOError, message:
  sendmsg(message)

command=""
if configuration.action == None:
  # Default command is SLEEP.  It is safer as no actual data can be lost going
  # to sleep where a shutdown my cause data lost because saving operations
  # could not be performed.
  command = APOCommand.commands[APOCommand.SLEEP]
  commandtext = APOCommand.SLEEP
if configuration.action == APOCommand.OTHER:

  command = configuration.actioncommand
  commandtext = "executing '" + command + "'"
else:
  command = APOCommand.commands[configuration.action]
  commandtext = APOCommand.commands[configuration.action]

#logger.debug("idletime=" + str(configuration.idletime))

sendmsg("Successfully started as PID: " + str(os.getpid()))
sendmsg("Command to execute when all conditions are met:  " + command)


######################################################################
# Starting thread that checks if any host is still alive.
# The global gHostsStillAlive variable is updated by this thread
# and used by the main one to get the list of all hosts still alive.
from HostsStillAliveCheckThread import *
hostsStillAliveCheckThread=HostsStillAliveCheckThread(configuration.hosts)
hostsStillAliveCheckThread.start()


######################################################################
# Lock file creation to ensure only one instance of this script is running.
file=open(pidfile, 'w')
file.write(str(os.getpid()))
file.close()


######################################################################
# The system must remain on for at least the 'startupdelay' first minutes
# it was started.
if not testmode:
  sendmsg("Startup sleep of " + str(configuration.startupdelay) + " minutes.")
  time.sleep(configuration.startupdelay*60)


######################################################################
# Loading kernel power management module.
# For the moment, not required.
#commands.getstatusoutput("/sbin/modprobe apm")

gLastInputEventTime = time.time()

class ApoDeviceObserverThread(threading.Thread):

  def __init__(self, sDevice):
    threading.Thread.__init__(self, name=sDevice)
    self.setDaemon(True)
    self.sDevice = sDevice
    self.sleep = 0

  def run(self):
    global gLastInputEventTime
    fd=open(self.sDevice, 'r')
    logger.debug("ApoDeviceObserverThread.run():  Check on " + \
        self.sDevice + " started.")
    self.finish = False
    lastEventTime = 0.0
    while not self.finish:
      if self.sleep > 0:
        time.sleep(self.sleep)
        self.sleep = 0

      try:
        fd.read(1)
      except IOError, ioerror:
        if ioerror.errno == errno.ENODEV:
          self.finish=True
          sendmsg("Device " + self.sDevice + " absent (No such device error)",\
                  syslog.LOG_NOTICE)
          continue
        else:
          raise
      currentTime=time.time()
      gLastInputEventTime=currentTime
      #print currentTime-lastEventTime
      # To reduce the quantity of output, we print only a few
      # of the events, for logger.debugging purposes.  Else, it is simply
      # to much.
      if currentTime > lastEventTime + 0.01:
        logger.debug("ApoDeviceObserverThread.run():  Activity detected on " + \
            self.sDevice + " at " + str(currentTime))
      lastEventTime = currentTime
    fd.close()

  def terminate(self):
    self.finish = True

  def sleep(self, timeout):
    self.sleep = timeout

DevicesArray   = []
ApoDevObsArray = []

try:
  spkrRE = re.compile(".*spkr.*")
  devicePath=None
  # Ubuntu 06.06 does not have any /dev/input/by-paty,
  # only /dev/input.
  for devicePath in [ "/dev/input/by-path", "/dev/input" ]:
    if os.path.exists(devicePath):
      break

  if devicePath == None:
    sendmsg("WARNING:  No input device detected.  " + \
            "Will not be able to detect user activity.")
  else:
    for path in os.listdir(devicePath):
      if spkrRE.search(path) != None:
        # Ignoring speaker devices.  I do not understand how a device
        # related to a speaker can be considered an input device.  A
        # microphone maybe?  Even if this is the case, if a user simply
        # leave the microphone on, it will always receive some ambient
        # sound even if the machine is not use.  We cannot make use of
        # this.  This device is available in Ubuntu 07.04 and 08.10
        # (2.6.24-17-generic).
        continue

      path = devicePath + "/" + path
      logger.debug("path = " + path)
      DevicesArray.append(path)

except OSError, oserror:
  if oserror.errno != errno.ENOENT:  # No such file or directory
    raise

for device in DevicesArray:
  logger.debug("Device = " + device)
  #apoDevObs=ApoDeviceObserverThread(device)
  #apoDevObs.start()
  #ApoDevObsArray.append(apoDevObs)

######################################################################
isToBePutOnHold = False
alivePrint      = False
sleepTimeLogged = False
try:
   while True:

     # Checking if the current hour is within the poweroff shutdown range.
     # Now contains the current hour.

     now = time.time()
     #logger.debug("UTC:  ", time.gmtime(now))
     #logger.debug("LOCAL:  ", time.localtime(now))
     nowtuple = time.localtime(now)
     nowhour = nowtuple[3]
     #logger.debug(nowhour)

     sleeptime = 0;
     if configuration.noshutdownrange[apoconfig.STARTHOUR] <= \
        configuration.noshutdownrange[apoconfig.ENDHOUR]:
       if nowhour >= configuration.noshutdownrange[apoconfig.STARTHOUR] and \
          nowhour < configuration.noshutdownrange[apoconfig.ENDHOUR]:
         shutdowntuple=(nowtuple[0], nowtuple[1], nowtuple[2],
                        configuration.noshutdownrange[apoconfig.ENDHOUR],
                        0, 0, nowtuple[6], nowtuple[7], nowtuple[8])
         #logger.debug(shutdowntuple)
         #logger.debug(nowtuple)
         sleeptime=time.mktime(shutdowntuple)-now+1
     else:
       if (nowhour >= configuration.noshutdownrange[apoconfig.STARTHOUR] and 
           nowhour <= 24) or \
           nowhour < configuration.noshutdownrange[apoconfig.ENDHOUR] :
         shutdowntuple=(nowtuple[0], nowtuple[1], nowtuple[2]+1,
                        configuration.noshutdownrange[apoconfig.ENDHOUR],
                        0, 0, nowtuple[6], nowtuple[7], nowtuple[8])
         #logger.debug(shutdowntuple)
         #logger.debug(nowtuple)
         sleeptime=time.mktime(shutdowntuple)-now+1

     if sleeptime > 0:
       # Using gmtime(sleeptime) here because localtime(0) is actually
       # 1969/12/31 19h00, thus if using localtime(sleeptime), we actually
       # print the sleeptime minus 5 hours, which is wrong.
       if sleepTimeLogged == False:
         sendmsg("Currently not in time range " + \
                 str(configuration.noshutdownrange) + \
                 " for " + commandtext + ".  Sleeping for " + \
                 time.strftime("%H:%M:%S", time.gmtime(sleeptime)),".")
         sleepTimeLogged = True
       alivePrint=False

       # Actually sleeping for 1 minute.  The problem is that when the system
       # is suspended or hibernated prior the expiration time, the sleep will
       # continue where it left of, without taking account the time that
       # lapsed during the sleep.

       # Say for example that sleeptime is 2 hours.  15 minutes after this
       # thread started sleeping, the user manually suspends the computer for
       # 3 hours.  Upon resuming, this thread will still continue to sleep for
       # 1:45 hours, despite it should be stopped.

       time.sleep(1*60)
       continue

     nowTime = time.time()
     timeElapsedSinceLastEvent = nowTime - gLastInputEventTime

     logger.debug("timeElapsedSinceLastEvent = " + str(timeElapsedSinceLastEvent))

     # If configuration.idletime is set to 0, that means that the user does
     # not want any of the console inputs to influence the shutdown decision.
     if configuration.idletime > 0 and \
        timeElapsedSinceLastEvent < configuration.idletime*60:
       sleeptime=None
       if testmode:
         sleeptime=2
       else:
         sleeptime=configuration.idletime*60
       logger.debug("Sleeping for " + str(sleeptime) + \
             "s following IdleTime configuration.")
       time.sleep(sleeptime)
       continue
    
     logger.debug("gHostsStillAlive = " + str(gHostsStillAlive))
     if len(gHostsStillAlive) > 0:
       if not alivePrint:
         sendmsg("Some hosts are still alive:  " + str(gHostsStillAlive))
       alivePrint=True
       continue
     else:
       while os.path.exists(cancelfile):
         if not isToBePutOnHold:
           isToBePutOnHold = True
           sendmsg(programname + \
                   " disabled as requested (detected presence of '" + \
                   cancelfile + "').")
         time.sleep(1*60)
         continue

       isToBePutOnHold = False
    
       sendmsg("All the conditions are met for running the action.", \
               syslog.LOG_ALERT)
       if testmode:
         print "Test mode:  would have run action '" + command \
               + "' at " + time.strftime("%H:%M:%S", (time.localtime(time.time())))
       else:
         #commands.getstatusoutput("nohup " + gShutdownCmd + " -h now")
         commands.getstatusoutput(command)
         #print "ERROR:  POWEROFF COMMAND DISABLED FOR logger.debugGING PURPOSES."



   # Only poweroff if it has been determined that this is the action to do.
   # Remember, autopoweroff could have received a SIGTERM (CTRL-C).
   #
   # The while loop can end when finish == True or if autopoweroff
   # receives a SIGTERM signal.
except:
  sigtermHandler(None, None)
